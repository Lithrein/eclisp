(%:include ("../../include/macros.eclisph"))

(import "utils")
(import "vec3")

(%:include <math.h>)

(defunion vec3
  (declare scope global)
  ((e (array 3 double)
      "Coordinates as an array."))
  "A 3d vector.")

(macro vec3-e (v) `(. ,v e))
(macro vec3-x (v) `(aref (. ,v e) 0))
(macro vec3-y (v) `(aref (. ,v e) 1))
(macro vec3-z (v) `(aref (. ,v e) 2))

(macro mkvec3 (x y z)
  "A convenience macro to instanciate 3d vectors."
  `(cast (union vec3) `((,,x ,,y ,,z))))

(macro mk-naryop (name binop)
  "A convenience macro to convert binary operators into n-ary operators."
  `(macro ,name (arg1 arg2 &body rest)
     (if (null rest)
         `(,',binop ,arg1 ,arg2)
       `(,',binop ,arg1 (,',name ,arg2 ,@rest)))))

(defun vec3_minus (v)
  "Unary minus operator on a 3d vector."
  (declare rtype (union vec3))
  (declare type (union vec3) v)
  
  (return (mkvec3 (- (vec3-x v)) (- (vec3-y v)) (- (vec3-z v)))))

(defun vec3_add (v1 v2)
  "Add two 3d vectors."
  (declare rtype (union vec3))
  (declare type (union vec3) v1 v2)
  
  (return (mkvec3 (+ (vec3-x v1) (vec3-x v2))
                  (+ (vec3-y v1) (vec3-y v2))
                  (+ (vec3-z v1) (vec3-z v2)))))
(mk-naryop vec3+ vec3_add)

(defun vec3_sub (v1 v2)
  "Substract two 3d vectors."
  (declare rtype (union vec3))
  (declare type (union vec3) v1 v2)
  
  (return (mkvec3 (- (vec3-x v1) (vec3-x v2))
                  (- (vec3-y v1) (vec3-y v2))
                  (- (vec3-z v1) (vec3-z v2)))))
(mk-naryop vec3- vec3_sub)

(defun vec3_mul (v1 v2)
  "Multiply two 3d vectors element-wise."
  (declare rtype (union vec3))
  (declare type (union vec3) v1 v2)
  
  (return (mkvec3 (* (vec3-x v1) (vec3-x v2))
                  (* (vec3-y v1) (vec3-y v2))
                  (* (vec3-z v1) (vec3-z v2)))))
(mk-naryop vec3* vec3_mul)

(defun vec3_div (v1 v2)
  "Divide two 3d vectors element-wise."
  (declare rtype (union vec3))
  (declare type (union vec3) v1 v2)
  
  (return (mkvec3 (/ (vec3-x v1) (vec3-x v2))
                  (/ (vec3-y v1) (vec3-y v2))
                  (/ (vec3-z v1) (vec3-z v2)))))
(mk-naryop vec3/ vec3_div)

(defun vec3_dot (v1 v2)
  "Compute the dot-product of two 3d vectors."
  (declare rtype double)
  (declare type (union vec3) v1 v2)
  
  (return (+ (* (vec3-x v1) (vec3-x v2))
             (* (vec3-y v1) (vec3-y v2))
             (* (vec3-z v1) (vec3-z v2)))))
(mk-naryop vec3. vec3_dot)

(defun vec3_cross (v1 v2)
  "Compute the cross-product of two 3d vectors."
  (declare rtype (union vec3))
  (declare type (union vec3) v1 v2)

  (return (mkvec3 (- (* (vec3-y v1) (vec3-z v2)) (* (vec3-z v1) (vec3-y v2)))
                  (- (* (vec3-z v1) (vec3-x v2)) (* (vec3-x v1) (vec3-z v2)))
                  (- (* (vec3-x v1) (vec3-y v2)) (* (vec3-y v1) (vec3-x v2))))))
(mk-naryop vec3x vec3_cross)

(defun vec3_sadd (v t)
  "Addition by a scalar"
  (declare rtype (union vec3))
  (declare type (union vec3) v)
  (declare type double t)

  (return (mkvec3 (+ (vec3-x v) t) (+ (vec3-y v) t) (+ (vec3-z v) t))))

(defun vec3_smul (v t)
  "Multiplication by a scalar"
  (declare rtype (union vec3))
  (declare type (union vec3) v)
  (declare type double t)

  (return (mkvec3 (* (vec3-x v) t) (* (vec3-y v) t) (* (vec3-z v) t))))

(defun vec3_sdiv (v t)
  "Division by a scalar"
  (declare rtype (union vec3))
  (declare type (union vec3) v)
  (declare type double t)

  (return (mkvec3 (/ (vec3-x v) t) (/ (vec3-y v) t) (/ (vec3-z v) t))))

(defun vec3_len2 (v)
  "Compute the length square of a 3d vector."
  (declare rtype double)
  (declare type (union vec3) v)

  (return (+ (* (vec3-x v) (vec3-x v))
             (* (vec3-y v) (vec3-y v))
             (* (vec3-z v) (vec3-z v)))))

(defun vec3_len (v)
  "Compute the length of a 3d vector.

This function may not be accurate for some extremal values of the double
precision floating-point range.  However, it should suffice in most cases,
even though not as precise as an hypothetical `hypot3' function."
  (declare rtype double)
  (declare type (union vec3) v)
  
  (return (sqrt (vec3_len2 v))))

(defun vec3_unit (v)
  "Compute the unit vector associated with `v'."
  (declare rtype (union vec3))
  (declare type (union vec3) v)
  
  (return (vec3_sdiv v (vec3_len v))))

(defun vec3_random ()
  "Pick a random 3d vector."
  (declare rtype (union vec3))
  
  (return (mkvec3 (random_double) (random_double) (random_double))))

(defun vec3_random_mm (min max)
  "Pick a random 3d vector whose components are within `min' and `max'."
  (declare rtype (union vec3))
  (declare type double min max)
  
  (return (mkvec3 (random_double_mm min max)
                  (random_double_mm min max)
                  (random_double_mm min max))))

(defun random_in_unit_sphere ()
  "Pick a random 3d vector within the unit sphere."
  (declare rtype (union vec3))
  
  (loop
    (def p (union vec3) (vec3_random_mm -1 1))
    (if (< (vec3_len2 p) 1) (return p))))

(defun random_unit_vector ()
  "Pick a random unit vector within the unit sphere."
  (declare rtype (union vec3))
  
  (return (vec3_unit (random_in_unit_sphere))))

(defun random_on_hemisphere (normal)
  "Pick a random vector in the same hemisphere as `normal'."
  (declare rtype (union vec3))
  (declare type (ptr union vec3) normal)
  
  (def on_unit_sphere (union vec3) (random_unit_vector))
  (if (> (vec3_dot on_unit_sphere *normal) 0.0)
      (return on_unit_sphere)
    (return (vec3_minus on_unit_sphere))))
